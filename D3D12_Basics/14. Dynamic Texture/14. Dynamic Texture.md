# 14. Dynamic Texture

## Dynamic Texture
- 동적으로 내용을 변경 가능
- 스프라이트 또는 3D Mesh 에 대한 텍스쳐로 사용 가능
- 디버깅 용도	
	- Deffered Render 같이 MRT 를 사용하는 렌더링 환경에서 각 Render Target 들을 2D 이미지로 화면에 출력하여 디버깅 할 수 있음
- 웹 브라우저 화면 또는 동영상 출력
- **Text 출력을 위한 기반 코드**

## Sprite 에 대한 실시간 업데이트
- 빈 Sprite 객체 생성
- 이미지 내용을 변경할 수 있는 텍스쳐 생성(== Dynamic Texture)
- 렌더러 바깥에서 해당 Dynamic Texture 에 이미지를 써넣음
- Sprite 를 그릴때 Dynamic Texture 를 전달 
- Dynamic Texture 에 업데이트할 내용은 Content Layer 에서 업데이트 함
	- 업데이트 된 내용을 D3D12Renderer 로 보내면 거기서 렌더링

## 예제 코드 분석
1. main.cpp (Content Layer)
```
wWinMain() 의 초기화부분
	// create sprite
	
	g_ImageWidth = 512;
	g_ImageHeight = 256;
	g_pImage = (BYTE*)malloc(g_ImageWidth * g_ImageHeight * 4);
	DWORD* pDest = (DWORD*)g_pImage;
	for (DWORD y = 0; y < g_ImageHeight; y++)
	{
		for (DWORD x = 0; x < g_ImageWidth; x++)
		{
			pDest[x + g_ImageWidth * y] = 0xff0000ff;
		}
	}
	g_pDynamicTexHandle = g_pRenderer->CreateDynamicTexture(g_ImageWidth, g_ImageHeight);
```
- 시스템 메모리에서 사용할 512 * 256 크기의  버퍼를 생성
	- 초기화 값인 0xff0000ff 는 little endian 으로 뒤에서부터 2바이트씩 RGBA
	- 즉, 0xff00ff 는 RGBA 로 { 255, 0, 0, 255 } 빨간색

```
main.cpp 의 Update()의 일부
// Update Texture
static DWORD g_dwCount = 0;
static DWORD g_dwTileColorR = 0;
static DWORD g_dwTileColorG = 0;
static DWORD g_dwTileColorB = 0;

const DWORD TILE_WIDTH = 16;
const DWORD TILE_HEIGHT = 16;

DWORD TILE_WIDTH_COUNT = g_ImageWidth / TILE_WIDTH;
DWORD TILE_HEIGHT_COUNT = g_ImageHeight / TILE_HEIGHT;

if (g_dwCount >= TILE_WIDTH_COUNT * TILE_HEIGHT_COUNT)
{
	g_dwCount = 0;
}
DWORD TileY = g_dwCount / TILE_WIDTH_COUNT;
DWORD TileX = g_dwCount % TILE_WIDTH_COUNT;

DWORD StartX = TileX * TILE_WIDTH;
DWORD StartY = TileY * TILE_HEIGHT;


//DWORD r = rand() % 256;
//DWORD g = rand() % 256;
//DWORD b = rand() % 256;

DWORD r = g_dwTileColorR;
DWORD g = g_dwTileColorG;
DWORD b = g_dwTileColorB;


DWORD* pDest = (DWORD*)g_pImage;
for (DWORD y = 0; y < 16; y++)
{
	for (DWORD x = 0; x < 16; x++)
	{
		if (StartX + x >= g_ImageWidth)
			__debugbreak();

		if (StartY + y >= g_ImageHeight)
			__debugbreak();

		pDest[(StartX + x) + (StartY + y) * g_ImageWidth] = 0xff000000 | (b << 16) | (g << 8) | r;
	}
}
g_dwCount++;
g_dwTileColorR += 8;
if (g_dwTileColorR > 255)
{
	g_dwTileColorR = 0;
	g_dwTileColorG += 8;
}
if (g_dwTileColorG > 255)
{
	g_dwTileColorG = 0;
	g_dwTileColorB += 8;
}
if (g_dwTileColorB > 255)
{
	g_dwTileColorB = 0;
}
g_pRenderer->UpdateTextureWithImage(g_pDynamicTexHandle, g_pImage, g_ImageWidth, g_ImageHeight);
```
- 텍스쳐 업데이트 코드로 크게 중요하지 않음
- 16x16 단위로 색상을 그라데이션으로 업데이트함 

```
main.cpp 의 RunGame() 의 일부
	// render dynamic texture
	g_pRenderer->RenderSpriteWithTex(g_pSpriteObjCommon, 0, 256 + 5 + 256 + 5, 0.5f, 0.5f, nullptr, 0.0f, g_pDynamicTexHandle);
```
- 이전 SpriteObject 의 렌더링과 동일

2. TEXTURE_HANDLE 의 변경 (typedef.h)
```
struct TEXTURE_HANDLE
{
	ID3D12Resource*	pTexResource;
	ID3D12Resource*	pUploadBuffer;
	D3D12_CPU_DESCRIPTOR_HANDLE srv;
	BOOL	bUpdated;
	SORT_LINK	Link;
};
```
- UploadBuffer, bUpdated, Link 가 추가됨
- 이제 텍스쳐가 동적으로 변경되므로 변경되었는지 체크하여 업로드버퍼를 이용해  GPU에 다시 복사해주어야 함 
- 다만 갱신이 될때마다 GPU에 복사하는 것은 안그래도 느린 작업을 여러번 하는 일임
	- 그러므로 Upload Buffer 의 갱신이 있을때 bUpdated 만 TRUE 로 바꾸고 나중에 한번에 GPU에 복사함 (1프레임당 1번)
- 나중에 DeleteTexture 할때 UploadBuffer 까지 Release 하는것을 빼먹지 말아야 함 

3. ```CD3D12Renderer::CreateDynamicTexture(UINT TexWidth, UINT TexHeight)```
```
void* CD3D12Renderer::CreateDynamicTexture(UINT TexWidth, UINT TexHeight)
{
	TEXTURE_HANDLE* pTexHandle = nullptr;

	ID3D12Resource* pTexResource = nullptr;
	ID3D12Resource* pUploadBuffer = nullptr;
	D3D12_CPU_DESCRIPTOR_HANDLE srv = {};


	DXGI_FORMAT TexFormat = DXGI_FORMAT_R8G8B8A8_UNORM;

	if (m_pResourceManager->CreateTexturePair(&pTexResource, &pUploadBuffer, TexWidth, TexHeight, TexFormat))
	{
		D3D12_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};
		SRVDesc.Format = TexFormat;
		SRVDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		SRVDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
		SRVDesc.Texture2D.MipLevels = 1;

		if (m_pSingleDescriptorAllocator->AllocDescriptorHandle(&srv))
		{
			m_pD3DDevice->CreateShaderResourceView(pTexResource, &SRVDesc, srv);

			pTexHandle = AllocTextureHandle();
			pTexHandle->pTexResource = pTexResource;
			pTexHandle->pUploadBuffer = pUploadBuffer;
			pTexHandle->srv = srv;
		}
		else
		{
			pTexResource->Release();
			pTexResource = nullptr;

			pUploadBuffer->Release();
			pUploadBuffer = nullptr;
		}
	}

	return pTexHandle;
}
```
- ResourceManager의 CreateTexturePair 를 이용
	- 이번부터 새로 추가된 함수
	- GPU 와 시스템 메모리 양쪽에 버퍼를 짝으로 만들어서 반환
		- 시스템 메모리는 Upload Buffer 로 사용(HEAP_TYPE_UPLOAD)
		- GPU 메모리는 시스템 메모리에서 복사(HEAP_TYPE_DEFAULT)

4 ```CD3D12Renderer::AllocTextureHandle()``` / ```CD3D12Renderer::FreeTextureHandle()```	
```
BOOL CSingleDescriptorAllocator::AllocDescriptorHandle(D3D12_CPU_DESCRIPTOR_HANDLE* pOutCPUHandle)
{
	BOOL	bResult = FALSE;

	DWORD	dwIndex = m_IndexCreator.Alloc();
	if (-1 != dwIndex)
	{
		CD3DX12_CPU_DESCRIPTOR_HANDLE DescriptorHandle(m_pHeap->GetCPUDescriptorHandleForHeapStart(), dwIndex, m_DescriptorSize);
		*pOutCPUHandle = DescriptorHandle;
		bResult = TRUE;
	}
	return bResult;
}
```
```
void CSingleDescriptorAllocator::FreeDescriptorHandle(D3D12_CPU_DESCRIPTOR_HANDLE DescriptorHandle)
{

	D3D12_CPU_DESCRIPTOR_HANDLE base = m_pHeap->GetCPUDescriptorHandleForHeapStart();
#ifdef _DEBUG
	if (base.ptr > DescriptorHandle.ptr)
		__debugbreak();
#endif
	DWORD dwIndex = (DWORD)(DescriptorHandle.ptr - base.ptr) / m_DescriptorSize;
	m_IndexCreator.Free(dwIndex);
}
D3D12_GPU_DESCRIPTOR_HANDLE CSingleDescriptorAllocator::GetGPUHandleFromCPUHandle(D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle)
{
	BOOL	bResult = FALSE;

	D3D12_CPU_DESCRIPTOR_HANDLE base = m_pHeap->GetCPUDescriptorHandleForHeapStart();
#ifdef _DEBUG
	if (base.ptr > cpuHandle.ptr)
		__debugbreak();
#endif
	DWORD dwIndex = (DWORD)(cpuHandle.ptr - base.ptr) / m_DescriptorSize;
	CD3DX12_GPU_DESCRIPTOR_HANDLE gpuHandle(m_pHeap->GetGPUDescriptorHandleForHeapStart(), dwIndex, m_DescriptorSize);

	return gpuHandle;
}
```
- 기존 new (다시 만든 코드는 make_shared) 로 하던 TEXTURE_HANDLE 생성을 디버깅이나 텍스쳐 순회를 위해 연결리스트를 만들어 기록함
- STL 에 std::list 는 안되나요
	- 상관없음. 샘플코드의 방법은 유영천 선생님의 취향
	- 단순한 C스타일 연결리스트로도 충분하다고 함 

5. ```CD3D12Renderer::UpdateTextureWithImage(void* pTexHandle, const BYTE* pSrcBits, UINT SrcWidth, UINT SrcHeight)```
```
void CD3D12Renderer::UpdateTextureWithImage(void* pTexHandle, const BYTE* pSrcBits, UINT SrcWidth, UINT SrcHeight)
{	
	TEXTURE_HANDLE* pTextureHandle = (TEXTURE_HANDLE*)pTexHandle;
	ID3D12Resource* pDestTexResource = pTextureHandle->pTexResource;
	ID3D12Resource* pUploadBuffer = pTextureHandle->pUploadBuffer;

	D3D12_RESOURCE_DESC Desc = pDestTexResource->GetDesc();
	if (SrcWidth > Desc.Width)
	{
		__debugbreak();
	}
	if (SrcHeight > Desc.Height)
	{
		__debugbreak();
	}
	D3D12_PLACED_SUBRESOURCE_FOOTPRINT Footprint;
	UINT	Rows = 0;
	UINT64	RowSize = 0;
	UINT64	TotalBytes = 0;

	m_pD3DDevice->GetCopyableFootprints(&Desc, 0, 1, 0, &Footprint, &Rows, &RowSize, &TotalBytes);

	BYTE*	pMappedPtr = nullptr;
	CD3DX12_RANGE writeRange(0, 0);

	HRESULT hr = pUploadBuffer->Map(0, &writeRange, reinterpret_cast<void**>(&pMappedPtr));
	if (FAILED(hr))
		__debugbreak();

	const BYTE* pSrc = pSrcBits;
	BYTE* pDest = pMappedPtr;
	for (UINT y = 0; y < SrcHeight; y++)
	{
		memcpy(pDest, pSrc, SrcWidth * 4);
		pSrc += (SrcWidth * 4);
		pDest += Footprint.Footprint.RowPitch;			
	}
	// Unmap
	pUploadBuffer->Unmap(0, nullptr);

	pTextureHandle->bUpdated = TRUE;
}
```
- 재미있게도 Pitch가 필요가 없음
	- API 에서 제공하는 함수라면 해당 API의 Align 에 맞게 Pitch가 필요했겠지만 지금은 단순 BYTE 메모리 안 작성된 텍스쳐이므로 Pitch값을 이미 알고있음 
	- Width * 4 바이트(rgba) 가 Pitch 
- 단순히 Upload Buffer 에다가 Map 으로 내용을 작성하고 Unmap 하는 함수임 
- ResourceBarrior / CopyTextureRegion 을 안하고 bResult 변수만 TRUE 로 변경함 
	- 나중에 렌더링(Draw) 직전에 UpdateTexture() 함수에서 한번에 몰아서 하기 때문임

6. ```CD3D12Renderer::RenderSpriteWithTex(void* pSprObjHandle, int iPosX, int iPosY, float fScaleX, float fScaleY, const RECT* pRect, float Z, void* pTexHandle)``` 의 변경사항
```
void CD3D12Renderer::RenderSpriteWithTex(void* pSprObjHandle, int iPosX, int iPosY, float fScaleX, float fScaleY, const RECT* pRect, float Z, void* pTexHandle)
{
	ID3D12GraphicsCommandList* pCommandList = m_ppCommandList[m_dwCurContextIndex];
	TEXTURE_HANDLE* pTexureHandle = (TEXTURE_HANDLE*)pTexHandle;

	CSpriteObject* pSpriteObj = (CSpriteObject*)pSprObjHandle;

	XMFLOAT2 Pos = { (float)iPosX, (float)iPosY };
	XMFLOAT2 Scale = { fScaleX, fScaleY };

	if (pTexureHandle->pUploadBuffer)
	{
		if (pTexureHandle->bUpdated)
		{
			UpdateTexture(m_pD3DDevice, pCommandList, pTexureHandle->pTexResource, pTexureHandle->pUploadBuffer);
		}
		else
		{
			int a = 0;
		}
		pTexureHandle->bUpdated = FALSE;
	}
	pSpriteObj->DrawWithTex(pCommandList, &Pos, &Scale, pRect, Z, pTexureHandle);
}
```
- 위에서 말한대로 TEXTURE_HANDLE 의 bResult 를 확인하여 텍스쳐를 GPU에 프레임당 한번만 복사함 

7. ```UpdateTexture()``` (D3DUtils.h)
```
void UpdateTexture(ID3D12Device* pD3DDevice, ID3D12GraphicsCommandList* pCommandList, ID3D12Resource* pDestTexResource, ID3D12Resource* pSrcTexResource)
{
	const DWORD MAX_SUB_RESOURCE_NUM = 32;
	D3D12_PLACED_SUBRESOURCE_FOOTPRINT Footprint[MAX_SUB_RESOURCE_NUM] = {};
	UINT	Rows[MAX_SUB_RESOURCE_NUM] = {};
	UINT64	RowSize[MAX_SUB_RESOURCE_NUM] = {};
	UINT64	TotalBytes = 0;

	D3D12_RESOURCE_DESC Desc = pDestTexResource->GetDesc();
	if (Desc.MipLevels > (UINT)_countof(Footprint))
		__debugbreak();

	pD3DDevice->GetCopyableFootprints(&Desc, 0, Desc.MipLevels, 0, Footprint, Rows, RowSize, &TotalBytes);

	pCommandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pDestTexResource, D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_COPY_DEST));
	for (DWORD i = 0; i < Desc.MipLevels; i++)
	{

		D3D12_TEXTURE_COPY_LOCATION	destLocation = {};
		destLocation.PlacedFootprint = Footprint[i];
		destLocation.pResource = pDestTexResource;
		destLocation.SubresourceIndex = i;
		destLocation.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;

		D3D12_TEXTURE_COPY_LOCATION	srcLocation = {};
		srcLocation.PlacedFootprint = Footprint[i];
		srcLocation.pResource = pSrcTexResource;
		srcLocation.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;

		pCommandList->CopyTextureRegion(&destLocation, 0, 0, 0, &srcLocation, nullptr);
	}
	pCommandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pDestTexResource, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE));

}
```
- 업데이트된 텍스쳐를 ResourceBarrior / CopyTextureRegion 으로 GPU 에다가 복사함
- 그런데 Excute 와 Wait 를 안한다?
	- Command List 에 계속 이어서 렌더링을 진행해도 무방할것으로 보임

9. SpriteObject 는 변경사항이 없음
- 시작부터 밖에서 텍스쳐를 받아서 렌더링도 가능하도록 디자인됨 
- 따라서 Renderer 에서 텍스쳐를 업데이트 했다면 그대로 넘겨주기만 하면 됨 
